# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

charset_0 = list(chain(range(34, 35), range(92, 93), range(47, 48), range(98, 99), range(102, 103), range(110, 111), range(114, 115), range(116, 117)))
charset_1 = list(chain(range(48, 58), range(97, 103), range(65, 71)))
charset_2 = list(chain(*multirange_diff(printable_unicode_ranges, [(0, 1),(31, 32),(34, 35),(45, 46),(92, 93)])))
charset_3 = list(chain(range(48, 58)))
charset_4 = list(chain(range(49, 58)))
charset_5 = list(chain(range(48, 58)))
charset_6 = list(chain(range(69, 70), range(101, 102)))
charset_7 = list(chain(range(43, 44), range(92, 93), range(45, 46)))
charset_8 = list(chain(range(32, 33), range(9, 10), range(10, 11), range(13, 14)))


class JSONUnlexer(Grammarinator):

    def __init__(self, *, max_depth=float('inf'), weights=None, cooldown=1.0):
        super(JSONUnlexer, self).__init__()
        self.unlexer = self
        self.max_depth = max_depth
        self.weights = weights or dict()
        self.cooldown = cooldown

    def EOF(self, *args, **kwargs):
        pass

    @depthcontrol
    def STRING(self):
        current = self.create_node(UnlexerRule(name='STRING'))
        choice = self.choice([0 if [1, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_0', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_0', choice)] = self.unlexer.weights.get(('alt_0', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='"'))
            if self.unlexer.max_depth >= 0:
                for _ in self.one_or_more():
                    choice = self.choice([0 if [1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_4', i), 1) for i, w in enumerate([1, 1])])
                    self.unlexer.weights[('alt_4', choice)] = self.unlexer.weights.get(('alt_4', choice), 1) * self.unlexer.cooldown
                    if choice == 0:
                        current += self.unlexer.ESC()
                    elif choice == 1:
                        current += self.unlexer.SAFECODEPOINT()

            current += self.create_node(UnlexerRule(src='"'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='"'))
            current += self.create_node(UnlexerRule(src='"'))
        return current
    STRING.min_depth = 0

    @depthcontrol
    def ESC(self):
        current = self.create_node(UnlexerRule(name='ESC'))
        current += self.create_node(UnlexerRule(src='\\'))
        choice = self.choice([0 if [0, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_11', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_11', choice)] = self.unlexer.weights.get(('alt_11', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src=self.char_from_list(charset_0)))
        elif choice == 1:
            current += self.unlexer.UNICODE()
        return current
    ESC.min_depth = 0

    @depthcontrol
    def UNICODE(self):
        current = self.create_node(UnlexerRule(name='UNICODE'))
        current += self.create_node(UnlexerRule(src='u'))
        current += self.unlexer.HEX()
        current += self.unlexer.HEX()
        current += self.unlexer.HEX()
        current += self.unlexer.HEX()
        return current
    UNICODE.min_depth = 1

    @depthcontrol
    def HEX(self):
        current = self.create_node(UnlexerRule(name='HEX'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_1)))
        return current
    HEX.min_depth = 0

    @depthcontrol
    def SAFECODEPOINT(self):
        current = self.create_node(UnlexerRule(name='SAFECODEPOINT'))
        current += UnlexerRule(src=self.char_from_list(charset_2))
        return current
    SAFECODEPOINT.min_depth = 0

    @depthcontrol
    def NUMBER(self):
        current = self.create_node(UnlexerRule(name='NUMBER'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src='-'))

        current += self.unlexer.INT()
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src='.'))
                if self.unlexer.max_depth >= 0:
                    for _ in self.one_or_more():
                        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_3)))


        if self.unlexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.unlexer.EXP()

        return current
    NUMBER.min_depth = 1

    @depthcontrol
    def INT(self):
        current = self.create_node(UnlexerRule(name='INT'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_20', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_20', choice)] = self.unlexer.weights.get(('alt_20', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='0'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src=self.char_from_list(charset_4)))
            if self.unlexer.max_depth >= 0:
                for _ in self.zero_or_more():
                    current += self.create_node(UnlexerRule(src=self.char_from_list(charset_5)))

        return current
    INT.min_depth = 0

    @depthcontrol
    def EXP(self):
        current = self.create_node(UnlexerRule(name='EXP'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_6)))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_one():
                current += self.create_node(UnlexerRule(src=self.char_from_list(charset_7)))

        current += self.unlexer.INT()
        return current
    EXP.min_depth = 1

    @depthcontrol
    def WS(self):
        current = self.create_node(UnlexerRule(name='WS'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.create_node(UnlexerRule(src=self.char_from_list(charset_8)))

        return current
    WS.min_depth = 0

