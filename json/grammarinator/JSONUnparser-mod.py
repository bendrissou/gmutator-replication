# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

import JSONUnlexer


class JSONUnparser(Grammarinator):

    def __init__(self, unlexer):
        super(JSONUnparser, self).__init__()
        self.unlexer = unlexer
    @depthcontrol
    def json(self):
        current = self.create_node(UnparserRule(name='json'))
        current += self.value()
        return current
    json.min_depth = 2

    @depthcontrol
    def obj(self):
        current = self.create_node(UnparserRule(name='obj'))
        choice = self.choice([0 if [3, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_22', i), 1) for i, w in enumerate([11, 1])])
        self.unlexer.weights[('alt_22', choice)] = self.unlexer.weights.get(('alt_22', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='{'))
            current += self.pair()
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_more():
                    current += self.create_node(UnlexerRule(src=','))
                    current += self.pair()

            current += self.create_node(UnlexerRule(src='}'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='{'))
            current += self.create_node(UnlexerRule(src='}'))
        return current
    obj.min_depth = 0

    @depthcontrol
    def pair(self):
        current = self.create_node(UnparserRule(name='pair'))
        current += self.unlexer.STRING()
        current += self.create_node(UnlexerRule(src=':'))
        current += self.value()
        return current
    pair.min_depth = 2

    @depthcontrol
    def arr(self):
        current = self.create_node(UnparserRule(name='arr'))
        choice = self.choice([0 if [2, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_32', i), 1) for i, w in enumerate([11, 1])])
        self.unlexer.weights[('alt_32', choice)] = self.unlexer.weights.get(('alt_32', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='['))
            current += self.value()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_more():
                    current += self.create_node(UnlexerRule(src=','))
                    current += self.value()

            current += self.create_node(UnlexerRule(src=']'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='['))
            current += self.create_node(UnlexerRule(src=']'))
        return current
    arr.min_depth = 0

    @depthcontrol
    def token(self):
        current = self.create_node(UnparserRule(name='token'))
        choice = self.choice([0 if [1, 2, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_41', i), 1) for i, w in enumerate([1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_41', choice)] = self.unlexer.weights.get(('alt_41', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.STRING()
        elif choice == 1:
            current += self.unlexer.NUMBER()
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='true'))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='false'))
        elif choice == 4:
            current += self.create_node(UnlexerRule(src='null'))
        return current
    token.min_depth = 0

    @depthcontrol
    def value(self):
        current = self.create_node(UnparserRule(name='value'))
        choice = self.choice([0 if [1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_50', i), 1) for i, w in enumerate([1, 11, 1])])
        self.unlexer.weights[('alt_50', choice)] = self.unlexer.weights.get(('alt_50', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.token()
        elif choice == 1:
            current += self.obj()
        elif choice == 2:
            current += self.arr()
        return current
    value.min_depth = 1

    default_rule = json

