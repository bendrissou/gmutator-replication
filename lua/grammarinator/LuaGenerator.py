# Generated by Grammarinator 23.7.post31+g3f15e2c

import itertools

from math import inf
from grammarinator.runtime import *

class LuaGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_size = RuleSize(0, 0)

    def chunk(self, parent=None):
        with UnparserRuleContext(self, 'chunk', parent) as current:
            self._reserve(1, self.block, parent=current)
            self.EOF(parent=current)
            return current
    chunk.min_size = RuleSize(3, 2)

    def block(self, parent=None):
        with UnparserRuleContext(self, 'block', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 0) as quant0:
                while quant0(current):
                    self.stat(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 1), 0) as quant1:
                while quant1(current):
                    self.laststat(parent=current)
            return current
    block.min_size = RuleSize(2, 1)

    def blockLoop(self, parent=None):
        with UnparserRuleContext(self, 'blockLoop', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 0) as quant0:
                while quant0(current):
                    self.statLoop(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 1), 0) as quant1:
                while quant1(current):
                    self.laststatLoop(parent=current)
            return current
    blockLoop.min_size = RuleSize(2, 1)

    def statLoop(self, parent=None):
        with UnparserRuleContext(self, 'statLoop', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(3, 3), RuleSize(4, 2), RuleSize(2, 3), RuleSize(1, 1), RuleSize(3, 3), RuleSize(3, 5), RuleSize(2, 4), RuleSize(3, 5), RuleSize(3, 9), RuleSize(3, 7), RuleSize(4, 6), RuleSize(4, 7), RuleSize(2, 2)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.T__0(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.varlist, parent=current)
                    self._reserve(1, self.T__1, parent=current)
                    self.explist(parent=current)
                elif choice0 == 2:
                    self.functioncall(parent=current)
                elif choice0 == 3:
                    self.label(parent=current)
                elif choice0 == 4:
                    self.T__2(parent=current)
                elif choice0 == 5:
                    self._reserve(2, self.T__3, parent=current)
                    self._reserve(1, self.blockLoop, parent=current)
                    self.T__4(parent=current)
                elif choice0 == 6:
                    self._reserve(4, self.T__5, parent=current)
                    self._reserve(3, self.exp, parent=current)
                    self._reserve(2, self.T__3, parent=current)
                    self._reserve(1, self.blockLoop, parent=current)
                    self.T__4(parent=current)
                elif choice0 == 7:
                    self._reserve(3, self.T__6, parent=current)
                    with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 2) as quant0:
                        while quant0(current):
                            self.statLoop(parent=current)
                    with QuantifierContext(self, 1, 0, 1, RuleSize(2, 1), 2) as quant1:
                        while quant1(current):
                            self.laststatB(parent=current)
                    self._reserve(1, self.T__7, parent=current)
                    self.exp(parent=current)
                elif choice0 == 8:
                    self._reserve(4, self.T__8, parent=current)
                    self._reserve(3, self.exp, parent=current)
                    self._reserve(2, self.T__9, parent=current)
                    self._reserve(1, self.blockLoop, parent=current)
                    with QuantifierContext(self, 2, 0, inf, RuleSize(3, 4), 1) as quant2:
                        while quant2(current):
                            self._reserve(3, self.T__10, parent=current)
                            self._reserve(2, self.exp, parent=current)
                            self._reserve(1, self.T__9, parent=current)
                            self.blockLoop(parent=current)
                    with QuantifierContext(self, 3, 0, 1, RuleSize(3, 2), 1) as quant3:
                        while quant3(current):
                            self._reserve(1, self.T__11, parent=current)
                            self.blockLoop(parent=current)
                    self.T__4(parent=current)
                elif choice0 == 9:
                    self._reserve(8, self.T__12, parent=current)
                    self._reserve(7, self.NAME, parent=current)
                    self._reserve(6, self.T__1, parent=current)
                    self._reserve(5, self.exp, parent=current)
                    self._reserve(4, self.T__13, parent=current)
                    self._reserve(3, self.exp, parent=current)
                    with QuantifierContext(self, 4, 0, 1, RuleSize(2, 2), 3) as quant4:
                        while quant4(current):
                            self._reserve(1, self.T__13, parent=current)
                            self.exp(parent=current)
                    self._reserve(2, self.T__3, parent=current)
                    self._reserve(1, self.blockLoop, parent=current)
                    self.T__4(parent=current)
                elif choice0 == 10:
                    self._reserve(6, self.T__12, parent=current)
                    self._reserve(5, self.namelist, parent=current)
                    self._reserve(4, self.T__14, parent=current)
                    self._reserve(3, self.explist, parent=current)
                    self._reserve(2, self.T__3, parent=current)
                    self._reserve(1, self.blockLoop, parent=current)
                    self.T__4(parent=current)
                elif choice0 == 11:
                    self._reserve(5, self.T__15, parent=current)
                    self._reserve(4, self.funcname, parent=current)
                    self.funcbody(parent=current)
                elif choice0 == 12:
                    self._reserve(6, self.T__16, parent=current)
                    self._reserve(5, self.T__15, parent=current)
                    self._reserve(4, self.NAME, parent=current)
                    self.funcbody(parent=current)
                elif choice0 == 13:
                    self._reserve(1, self.T__16, parent=current)
                    self.attnamelist(parent=current)
                    with QuantifierContext(self, 5, 0, 1, RuleSize(3, 2), 0) as quant5:
                        while quant5(current):
                            self._reserve(1, self.T__1, parent=current)
                            self.explist(parent=current)
            return current
    statLoop.min_size = RuleSize(1, 1)

    def stat(self, parent=None):
        with UnparserRuleContext(self, 'stat', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(3, 3), RuleSize(4, 2), RuleSize(2, 3), RuleSize(3, 3), RuleSize(3, 5), RuleSize(2, 4), RuleSize(3, 5), RuleSize(3, 9), RuleSize(3, 7), RuleSize(4, 6), RuleSize(4, 7), RuleSize(2, 2)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.T__0(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.varlist, parent=current)
                    self._reserve(1, self.T__1, parent=current)
                    self.explist(parent=current)
                elif choice0 == 2:
                    self.functioncall(parent=current)
                elif choice0 == 3:
                    self.label(parent=current)
                elif choice0 == 4:
                    self._reserve(2, self.T__3, parent=current)
                    self._reserve(1, self.block, parent=current)
                    self.T__4(parent=current)
                elif choice0 == 5:
                    self._reserve(4, self.T__5, parent=current)
                    self._reserve(3, self.exp, parent=current)
                    self._reserve(2, self.T__3, parent=current)
                    self._reserve(1, self.blockLoop, parent=current)
                    self.T__4(parent=current)
                elif choice0 == 6:
                    self._reserve(3, self.T__6, parent=current)
                    with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 2) as quant0:
                        while quant0(current):
                            self.statLoop(parent=current)
                    with QuantifierContext(self, 1, 0, 1, RuleSize(2, 1), 2) as quant1:
                        while quant1(current):
                            self.laststatB(parent=current)
                    self._reserve(1, self.T__7, parent=current)
                    self.exp(parent=current)
                elif choice0 == 7:
                    self._reserve(4, self.T__8, parent=current)
                    self._reserve(3, self.exp, parent=current)
                    self._reserve(2, self.T__9, parent=current)
                    self._reserve(1, self.block, parent=current)
                    with QuantifierContext(self, 2, 0, inf, RuleSize(3, 4), 1) as quant2:
                        while quant2(current):
                            self._reserve(3, self.T__10, parent=current)
                            self._reserve(2, self.exp, parent=current)
                            self._reserve(1, self.T__9, parent=current)
                            self.block(parent=current)
                    with QuantifierContext(self, 3, 0, 1, RuleSize(3, 2), 1) as quant3:
                        while quant3(current):
                            self._reserve(1, self.T__11, parent=current)
                            self.block(parent=current)
                    self.T__4(parent=current)
                elif choice0 == 8:
                    self._reserve(8, self.T__12, parent=current)
                    self._reserve(7, self.NAME, parent=current)
                    self._reserve(6, self.T__1, parent=current)
                    self._reserve(5, self.exp, parent=current)
                    self._reserve(4, self.T__13, parent=current)
                    self._reserve(3, self.exp, parent=current)
                    with QuantifierContext(self, 4, 0, 1, RuleSize(2, 2), 3) as quant4:
                        while quant4(current):
                            self._reserve(1, self.T__13, parent=current)
                            self.exp(parent=current)
                    self._reserve(2, self.T__3, parent=current)
                    self._reserve(1, self.blockLoop, parent=current)
                    self.T__4(parent=current)
                elif choice0 == 9:
                    self._reserve(6, self.T__12, parent=current)
                    self._reserve(5, self.namelist, parent=current)
                    self._reserve(4, self.T__14, parent=current)
                    self._reserve(3, self.explist, parent=current)
                    self._reserve(2, self.T__3, parent=current)
                    self._reserve(1, self.blockLoop, parent=current)
                    self.T__4(parent=current)
                elif choice0 == 10:
                    self._reserve(5, self.T__15, parent=current)
                    self._reserve(4, self.funcname, parent=current)
                    self.funcbody(parent=current)
                elif choice0 == 11:
                    self._reserve(6, self.T__16, parent=current)
                    self._reserve(5, self.T__15, parent=current)
                    self._reserve(4, self.NAME, parent=current)
                    self.funcbody(parent=current)
                elif choice0 == 12:
                    self._reserve(1, self.T__16, parent=current)
                    self.attnamelist(parent=current)
                    with QuantifierContext(self, 5, 0, 1, RuleSize(3, 2), 0) as quant5:
                        while quant5(current):
                            self._reserve(1, self.T__1, parent=current)
                            self.explist(parent=current)
            return current
    stat.min_size = RuleSize(1, 1)

    def attnamelist(self, parent=None):
        with UnparserRuleContext(self, 'attnamelist', parent) as current:
            self.attrclose = 1
            self.NAME(parent=current)
            self.attrib(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.T__13, parent=current)
                    self.NAME(parent=current)
                    self.attrib(parent=current)
            return current
    attnamelist.min_size = RuleSize(1, 1)

    def attrib(self, parent=None):
        with UnparserRuleContext(self, 'attrib', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 3), 0) as quant0:
                while quant0(current):
                    self._reserve(2, self.T__17, parent=current)
                    with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 1, (1, self.attrclose)) as alt0:
                        choice0 = alt0(current)
                        if choice0 == 0:
                            self.T__18(parent=current)
                        elif choice0 == 1:
                            self.T__19(parent=current)
                            self.attrclose = 0
                    self.T__20(parent=current)
            return current
    attrib.min_size = RuleSize(0, 0)

    def laststatLoop(self, parent=None):
        with UnparserRuleContext(self, 'laststatLoop', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.T__21(parent=current)
                    with QuantifierContext(self, 0, 0, 1, RuleSize(3, 1), 0) as quant0:
                        while quant0(current):
                            self.explist(parent=current)
                elif choice0 == 1:
                    self.T__2(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.T__0(parent=current)
            return current
    laststatLoop.min_size = RuleSize(1, 1)

    def laststatB(self, parent=None):
        with UnparserRuleContext(self, 'laststatB', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.T__21(parent=current)
                    with QuantifierContext(self, 0, 0, 1, RuleSize(3, 1), 0) as quant0:
                        while quant0(current):
                            self.explist(parent=current)
                elif choice0 == 1:
                    self.T__2(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.T__0(parent=current)
            return current
    laststatB.min_size = RuleSize(1, 1)

    def laststat(self, parent=None):
        with UnparserRuleContext(self, 'laststat', parent) as current:
            self.T__21(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.explist(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.T__0(parent=current)
            return current
    laststat.min_size = RuleSize(1, 1)

    def label(self, parent=None):
        with UnparserRuleContext(self, 'label', parent) as current:
            self._reserve(2, self.T__22, parent=current)
            self._reserve(1, self.NAME, parent=current)
            self.T__22(parent=current)
            return current
    label.min_size = RuleSize(1, 3)

    def funcname(self, parent=None):
        with UnparserRuleContext(self, 'funcname', parent) as current:
            self.NAME(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.T__23, parent=current)
                    self.NAME(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(1, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.T__24, parent=current)
                    self.NAME(parent=current)
            return current
    funcname.min_size = RuleSize(1, 1)

    def varlist(self, parent=None):
        with UnparserRuleContext(self, 'varlist', parent) as current:
            self.var(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(2, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.T__13, parent=current)
                    self.var(parent=current)
            return current
    varlist.min_size = RuleSize(2, 1)

    def namelist(self, parent=None):
        with UnparserRuleContext(self, 'namelist', parent) as current:
            self.NAME(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.T__13, parent=current)
                    self.NAME(parent=current)
            return current
    namelist.min_size = RuleSize(1, 1)

    def explist(self, parent=None):
        with UnparserRuleContext(self, 'explist', parent) as current:
            with QuantifierContext(self, 0, 0, inf, RuleSize(2, 2), 1) as quant0:
                while quant0(current):
                    self._reserve(1, self.exp, parent=current)
                    self.T__13(parent=current)
            self.exp(parent=current)
            return current
    explist.min_size = RuleSize(2, 1)

    def exp(self, parent=None):
        with UnparserRuleContext(self, 'exp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(3, 2), RuleSize(2, 1), RuleSize(5, 5), RuleSize(4, 1), RuleSize(2, 2), RuleSize(2, 3), RuleSize(2, 2), RuleSize(2, 3), RuleSize(2, 3), RuleSize(2, 3), RuleSize(2, 3), RuleSize(2, 3), RuleSize(2, 3), RuleSize(2, 3)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.T__25(parent=current)
                elif choice0 == 1:
                    self.T__26(parent=current)
                elif choice0 == 2:
                    self.T__27(parent=current)
                elif choice0 == 3:
                    self.number(parent=current)
                elif choice0 == 4:
                    self.string(parent=current)
                elif choice0 == 5:
                    self.functiondef(parent=current)
                elif choice0 == 6:
                    self.prefixexp(parent=current)
                elif choice0 == 7:
                    self.tableconstructor(parent=current)
                elif choice0 == 8:
                    self._reserve(2, self.exp, parent=current)
                    self._reserve(1, self.operatorPower, parent=current)
                    self.exp(parent=current)
                elif choice0 == 9:
                    self._reserve(1, self.operatorUnary, parent=current)
                    self.exp(parent=current)
                elif choice0 == 10:
                    self._reserve(2, self.exp, parent=current)
                    self._reserve(1, self.operatorMulDivMod, parent=current)
                    self.exp(parent=current)
                elif choice0 == 11:
                    self._reserve(2, self.exp, parent=current)
                    self._reserve(1, self.operatorAddSub, parent=current)
                    self.exp(parent=current)
                elif choice0 == 12:
                    self._reserve(2, self.exp, parent=current)
                    self._reserve(1, self.operatorStrcat, parent=current)
                    self.exp(parent=current)
                elif choice0 == 13:
                    self._reserve(2, self.exp, parent=current)
                    self._reserve(1, self.operatorComparison, parent=current)
                    self.exp(parent=current)
                elif choice0 == 14:
                    self._reserve(2, self.exp, parent=current)
                    self._reserve(1, self.operatorAnd, parent=current)
                    self.exp(parent=current)
                elif choice0 == 15:
                    self._reserve(2, self.exp, parent=current)
                    self._reserve(1, self.operatorOr, parent=current)
                    self.exp(parent=current)
                elif choice0 == 16:
                    self._reserve(2, self.exp, parent=current)
                    self._reserve(1, self.operatorBitwise, parent=current)
                    self.exp(parent=current)
            return current
    exp.min_size = RuleSize(1, 1)

    def prefixexp(self, parent=None):
        with UnparserRuleContext(self, 'prefixexp', parent) as current:
            self.varOrExp(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.nameAndArgs(parent=current)
            return current
    prefixexp.min_size = RuleSize(3, 1)

    def functioncall(self, parent=None):
        with UnparserRuleContext(self, 'functioncall', parent) as current:
            self._reserve(1, self.varOrExp, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.nameAndArgs(parent=current)
            return current
    functioncall.min_size = RuleSize(3, 2)

    def varOrExp(self, parent=None):
        with UnparserRuleContext(self, 'varOrExp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(2, 3)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.var(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.T__28, parent=current)
                    self._reserve(1, self.exp, parent=current)
                    self.T__29(parent=current)
            return current
    varOrExp.min_size = RuleSize(2, 1)

    def var(self, parent=None):
        with UnparserRuleContext(self, 'var', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(2, 5)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.NAME(parent=current)
                elif choice0 == 1:
                    self._reserve(4, self.T__28, parent=current)
                    self._reserve(3, self.exp, parent=current)
                    self._reserve(2, self.T__29, parent=current)
                    self.varSuffix(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(2, 2), 0) as quant0:
                while quant0(current):
                    self.varSuffix(parent=current)
            return current
    var.min_size = RuleSize(1, 1)

    def varSuffix(self, parent=None):
        with UnparserRuleContext(self, 'varSuffix', parent) as current:
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 1), 2) as quant0:
                while quant0(current):
                    self.nameAndArgs(parent=current)
            with AlternationContext(self, 0, (RuleSize(2, 3), RuleSize(1, 2)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(2, self.T__30, parent=current)
                    self._reserve(1, self.exp, parent=current)
                    self.T__31(parent=current)
                elif choice0 == 1:
                    self._reserve(1, self.T__23, parent=current)
                    self.NAME(parent=current)
            return current
    varSuffix.min_size = RuleSize(1, 2)

    def nameAndArgs(self, parent=None):
        with UnparserRuleContext(self, 'nameAndArgs', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 2), 1) as quant0:
                while quant0(current):
                    self._reserve(1, self.T__24, parent=current)
                    self.NAME(parent=current)
            self.args(parent=current)
            return current
    nameAndArgs.min_size = RuleSize(2, 1)

    def args(self, parent=None):
        with UnparserRuleContext(self, 'args', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 2), RuleSize(2, 2), RuleSize(2, 1)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(1, self.T__28, parent=current)
                    with QuantifierContext(self, 0, 0, 1, RuleSize(3, 1), 1) as quant0:
                        while quant0(current):
                            self.explist(parent=current)
                    self.T__29(parent=current)
                elif choice0 == 1:
                    self.tableconstructor(parent=current)
                elif choice0 == 2:
                    self.string(parent=current)
            return current
    args.min_size = RuleSize(1, 1)

    def functiondef(self, parent=None):
        with UnparserRuleContext(self, 'functiondef', parent) as current:
            self._reserve(4, self.T__15, parent=current)
            self.funcbody(parent=current)
            return current
    functiondef.min_size = RuleSize(4, 5)

    def funcbody(self, parent=None):
        with UnparserRuleContext(self, 'funcbody', parent) as current:
            self._reserve(3, self.T__28, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 1), 3) as quant0:
                while quant0(current):
                    self.parlist(parent=current)
            self._reserve(2, self.T__29, parent=current)
            self._reserve(1, self.block, parent=current)
            self.T__4(parent=current)
            return current
    funcbody.min_size = RuleSize(3, 4)

    def parlist(self, parent=None):
        with UnparserRuleContext(self, 'parlist', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.namelist(parent=current)
                    with QuantifierContext(self, 0, 0, 1, RuleSize(1, 2), 0) as quant0:
                        while quant0(current):
                            self._reserve(1, self.T__13, parent=current)
                            self.T__32(parent=current)
                elif choice0 == 1:
                    self.T__32(parent=current)
            return current
    parlist.min_size = RuleSize(1, 1)

    def tableconstructor(self, parent=None):
        with UnparserRuleContext(self, 'tableconstructor', parent) as current:
            self._reserve(1, self.T__33, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 1), 1) as quant0:
                while quant0(current):
                    self.fieldlist(parent=current)
            self.T__34(parent=current)
            return current
    tableconstructor.min_size = RuleSize(1, 2)

    def fieldlist(self, parent=None):
        with UnparserRuleContext(self, 'fieldlist', parent) as current:
            self.field(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.fieldsep, parent=current)
                    self.field(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 1), 0) as quant1:
                while quant1(current):
                    self.fieldsep(parent=current)
            return current
    fieldlist.min_size = RuleSize(3, 1)

    def field(self, parent=None):
        with UnparserRuleContext(self, 'field', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 5), RuleSize(2, 3), RuleSize(2, 1)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(4, self.T__30, parent=current)
                    self._reserve(3, self.exp, parent=current)
                    self._reserve(2, self.T__31, parent=current)
                    self._reserve(1, self.T__1, parent=current)
                    self.exp(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.NAME, parent=current)
                    self._reserve(1, self.T__1, parent=current)
                    self.exp(parent=current)
                elif choice0 == 2:
                    self.exp(parent=current)
            return current
    field.min_size = RuleSize(2, 1)

    def fieldsep(self, parent=None):
        with UnparserRuleContext(self, 'fieldsep', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.T__13, self.T__0][alt0(current)](parent=current)
            return current
    fieldsep.min_size = RuleSize(1, 1)

    def operatorOr(self, parent=None):
        with UnparserRuleContext(self, 'operatorOr', parent) as current:
            self.T__35(parent=current)
            return current
    operatorOr.min_size = RuleSize(1, 1)

    def operatorAnd(self, parent=None):
        with UnparserRuleContext(self, 'operatorAnd', parent) as current:
            self.T__36(parent=current)
            return current
    operatorAnd.min_size = RuleSize(1, 1)

    def operatorComparison(self, parent=None):
        with UnparserRuleContext(self, 'operatorComparison', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1, 1)) as alt0:
                [self.T__17, self.T__20, self.T__37, self.T__38, self.T__39, self.T__40][alt0(current)](parent=current)
            return current
    operatorComparison.min_size = RuleSize(1, 1)

    def operatorStrcat(self, parent=None):
        with UnparserRuleContext(self, 'operatorStrcat', parent) as current:
            self.T__41(parent=current)
            return current
    operatorStrcat.min_size = RuleSize(1, 1)

    def operatorAddSub(self, parent=None):
        with UnparserRuleContext(self, 'operatorAddSub', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.T__42, self.T__43][alt0(current)](parent=current)
            return current
    operatorAddSub.min_size = RuleSize(1, 1)

    def operatorMulDivMod(self, parent=None):
        with UnparserRuleContext(self, 'operatorMulDivMod', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1)) as alt0:
                [self.T__44, self.T__45, self.T__46, self.T__47][alt0(current)](parent=current)
            return current
    operatorMulDivMod.min_size = RuleSize(1, 1)

    def operatorBitwise(self, parent=None):
        with UnparserRuleContext(self, 'operatorBitwise', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1)) as alt0:
                [self.T__48, self.T__49, self.T__50, self.T__51, self.T__52][alt0(current)](parent=current)
            return current
    operatorBitwise.min_size = RuleSize(1, 1)

    def operatorUnary(self, parent=None):
        with UnparserRuleContext(self, 'operatorUnary', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1)) as alt0:
                [self.T__53, self.T__54, self.T__43, self.T__50][alt0(current)](parent=current)
            return current
    operatorUnary.min_size = RuleSize(1, 1)

    def operatorPower(self, parent=None):
        with UnparserRuleContext(self, 'operatorPower', parent) as current:
            self.T__55(parent=current)
            return current
    operatorPower.min_size = RuleSize(1, 1)

    def number(self, parent=None):
        with UnparserRuleContext(self, 'number', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 2), RuleSize(2, 2), RuleSize(2, 2), RuleSize(2, 2)), 0, (1, 1, 1, 1)) as alt0:
                [self.INT, self.HEX, self.FLOAT, self.HEX_FLOAT][alt0(current)](parent=current)
            return current
    number.min_size = RuleSize(2, 2)

    def string(self, parent=None):
        with UnparserRuleContext(self, 'string', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(2, 2)), 0, (1, 1, 1)) as alt0:
                [self.NORMALSTRING, self.CHARSTRING, self.LONGSTRING][alt0(current)](parent=current)
            return current
    string.min_size = RuleSize(1, 1)

    def NAME(self, parent=None):
        with UnlexerRuleContext(self, 'NAME', parent) as current:
            current.src += 'name_'
            current.src += self._model.charset(current, 0, self._charsets[1])
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 1, self._charsets[2])
            return current
    NAME.min_size = RuleSize(0, 0)

    def NORMALSTRING(self, parent=None):
        with UnlexerRuleContext(self, 'NORMALSTRING', parent) as current:
            current.src += '"'
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                        choice0 = alt0(current)
                        if choice0 == 0:
                            self.EscapeSequence(parent=current)
                        elif choice0 == 1:
                            current.src += self._model.charset(current, 0, self._charsets[3])
            current.src += '"'
            return current
    NORMALSTRING.min_size = RuleSize(0, 0)

    def CHARSTRING(self, parent=None):
        with UnlexerRuleContext(self, 'CHARSTRING', parent) as current:
            current.src += '\''
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                        choice0 = alt0(current)
                        if choice0 == 0:
                            self.EscapeSequence(parent=current)
                        elif choice0 == 1:
                            current.src += self._model.charset(current, 0, self._charsets[2])
            current.src += '\''
            return current
    CHARSTRING.min_size = RuleSize(0, 0)

    def LONGSTRING(self, parent=None):
        with UnlexerRuleContext(self, 'LONGSTRING', parent) as current:
            current.src += '['
            self.NESTED_STR(parent=current)
            current.src += ']'
            return current
    LONGSTRING.min_size = RuleSize(1, 1)

    def NESTED_STR(self, parent=None):
        with UnlexerRuleContext(self, 'NESTED_STR', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    current.src += '='
                    self.NESTED_STR(parent=current)
                    current.src += '='
                elif choice0 == 1:
                    current.src += '=['
                    with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                        while quant0(current):
                            current.src += self._model.charset(current, 0, self._charsets[0])
                    current.src += ']='
            return current
    NESTED_STR.min_size = RuleSize(0, 0)

    def INT(self, parent=None):
        with UnlexerRuleContext(self, 'INT', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.Digit(parent=current)
            return current
    INT.min_size = RuleSize(1, 1)

    def HEX(self, parent=None):
        with UnlexerRuleContext(self, 'HEX', parent) as current:
            current.src += '0'
            current.src += self._model.charset(current, 0, self._charsets[4])
            with QuantifierContext(self, 0, 1, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.HexDigit(parent=current)
            return current
    HEX.min_size = RuleSize(1, 1)

    def FLOAT(self, parent=None):
        with UnlexerRuleContext(self, 'FLOAT', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(2, 3)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    with QuantifierContext(self, 0, 1, inf, RuleSize(1, 1), 0) as quant0:
                        while quant0(current):
                            self.Digit(parent=current)
                    current.src += '.'
                    with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.Digit(parent=current)
                    with QuantifierContext(self, 2, 0, 1, RuleSize(2, 2), 0) as quant2:
                        while quant2(current):
                            self.ExponentPart(parent=current)
                elif choice0 == 1:
                    current.src += '.'
                    with QuantifierContext(self, 3, 1, inf, RuleSize(1, 1), 0) as quant3:
                        while quant3(current):
                            self.Digit(parent=current)
                    with QuantifierContext(self, 4, 0, 1, RuleSize(2, 2), 0) as quant4:
                        while quant4(current):
                            self.ExponentPart(parent=current)
                elif choice0 == 2:
                    with QuantifierContext(self, 5, 1, inf, RuleSize(1, 1), 2) as quant5:
                        while quant5(current):
                            self.Digit(parent=current)
                    self.ExponentPart(parent=current)
            return current
    FLOAT.min_size = RuleSize(1, 1)

    def HEX_FLOAT(self, parent=None):
        with UnlexerRuleContext(self, 'HEX_FLOAT', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(2, 3)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    current.src += '0'
                    current.src += self._model.charset(current, 0, self._charsets[4])
                    with QuantifierContext(self, 0, 1, inf, RuleSize(1, 1), 0) as quant0:
                        while quant0(current):
                            self.HexDigit(parent=current)
                    current.src += '.'
                    with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.HexDigit(parent=current)
                    with QuantifierContext(self, 2, 0, 1, RuleSize(2, 2), 0) as quant2:
                        while quant2(current):
                            self.HexExponentPart(parent=current)
                elif choice0 == 1:
                    current.src += '0'
                    current.src += self._model.charset(current, 1, self._charsets[4])
                    current.src += '.'
                    with QuantifierContext(self, 3, 1, inf, RuleSize(1, 1), 0) as quant3:
                        while quant3(current):
                            self.HexDigit(parent=current)
                    with QuantifierContext(self, 4, 0, 1, RuleSize(2, 2), 0) as quant4:
                        while quant4(current):
                            self.HexExponentPart(parent=current)
                elif choice0 == 2:
                    current.src += '0'
                    current.src += self._model.charset(current, 2, self._charsets[4])
                    with QuantifierContext(self, 5, 1, inf, RuleSize(1, 1), 2) as quant5:
                        while quant5(current):
                            self.HexDigit(parent=current)
                    self.HexExponentPart(parent=current)
            return current
    HEX_FLOAT.min_size = RuleSize(1, 1)

    def ExponentPart(self, parent=None):
        with UnlexerRuleContext(self, 'ExponentPart', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[5])
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 1) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 1, self._charsets[6])
            with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.Digit(parent=current)
            return current
    ExponentPart.min_size = RuleSize(1, 1)

    def HexExponentPart(self, parent=None):
        with UnlexerRuleContext(self, 'HexExponentPart', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[7])
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 1) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 1, self._charsets[6])
            with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.Digit(parent=current)
            return current
    HexExponentPart.min_size = RuleSize(1, 1)

    def EscapeSequence(self, parent=None):
        with UnlexerRuleContext(self, 'EscapeSequence', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0), RuleSize(2, 2), RuleSize(2, 3), RuleSize(2, 2)), 0, (1, 1, 1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    current.src += '\\'
                    current.src += self._model.charset(current, 0, self._charsets[8])
                elif choice0 == 1:
                    current.src += '\\'
                    with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 0) as quant0:
                        while quant0(current):
                            current.src += '\r'
                    current.src += '\n'
                elif choice0 == 2:
                    self.DecimalEscape(parent=current)
                elif choice0 == 3:
                    self.HexEscape(parent=current)
                elif choice0 == 4:
                    self.UtfEscape(parent=current)
            return current
    EscapeSequence.min_size = RuleSize(0, 0)

    def DecimalEscape(self, parent=None):
        with UnlexerRuleContext(self, 'DecimalEscape', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 2), RuleSize(1, 1)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    current.src += '\\'
                    self.Digit(parent=current)
                elif choice0 == 1:
                    current.src += '\\'
                    self._reserve(1, self.Digit, parent=current)
                    self.Digit(parent=current)
                elif choice0 == 2:
                    current.src += '\\'
                    current.src += self._model.charset(current, 0, self._charsets[9])
                    current.src += self._model.charset(current, 1, self._charsets[10])
                    self.Digit(parent=current)
            return current
    DecimalEscape.min_size = RuleSize(1, 1)

    def HexEscape(self, parent=None):
        with UnlexerRuleContext(self, 'HexEscape', parent) as current:
            current.src += '\\'
            current.src += 'x'
            self._reserve(1, self.HexDigit, parent=current)
            self.HexDigit(parent=current)
            return current
    HexEscape.min_size = RuleSize(1, 2)

    def UtfEscape(self, parent=None):
        with UnlexerRuleContext(self, 'UtfEscape', parent) as current:
            current.src += '\\'
            current.src += 'u{'
            with QuantifierContext(self, 0, 1, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.HexDigit(parent=current)
            current.src += '}'
            return current
    UtfEscape.min_size = RuleSize(1, 1)

    def Digit(self, parent=None):
        with UnlexerRuleContext(self, 'Digit', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[11])
            return current
    Digit.min_size = RuleSize(0, 0)

    def HexDigit(self, parent=None):
        with UnlexerRuleContext(self, 'HexDigit', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[12])
            return current
    HexDigit.min_size = RuleSize(0, 0)

    def SingleLineInputCharacter(self, parent=None):
        with UnlexerRuleContext(self, 'SingleLineInputCharacter', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[0])
            return current
    SingleLineInputCharacter.min_size = RuleSize(0, 0)

    def COMMENT(self, parent=None):
        with UnlexerRuleContext(self, 'COMMENT', parent) as current:
            current.src += '--['
            self.NESTED_STR(parent=current)
            current.src += ']'
            return current
    COMMENT.min_size = RuleSize(1, 1)

    def LINE_COMMENT(self, parent=None):
        with UnlexerRuleContext(self, 'LINE_COMMENT', parent) as current:
            current.src += '--'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SingleLineInputCharacter(parent=current)
            return current
    LINE_COMMENT.min_size = RuleSize(0, 0)

    def WS(self, parent=None):
        with UnlexerRuleContext(self, 'WS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[13])
            return current
    WS.min_size = RuleSize(0, 0)

    def SHEBANG(self, parent=None):
        with UnlexerRuleContext(self, 'SHEBANG', parent) as current:
            current.src += '#'
            current.src += '!'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SingleLineInputCharacter(parent=current)
            return current
    SHEBANG.min_size = RuleSize(0, 0)

    def T__0(self, parent=None):
        with UnlexerRuleContext(self, 'T__0', parent) as current:
            current.src += ';'
            return current
    T__0.min_size = RuleSize(0, 0)

    def T__1(self, parent=None):
        with UnlexerRuleContext(self, 'T__1', parent) as current:
            current.src += '='
            return current
    T__1.min_size = RuleSize(0, 0)

    def T__2(self, parent=None):
        with UnlexerRuleContext(self, 'T__2', parent) as current:
            current.src += 'break'
            return current
    T__2.min_size = RuleSize(0, 0)

    def T__3(self, parent=None):
        with UnlexerRuleContext(self, 'T__3', parent) as current:
            current.src += 'do'
            return current
    T__3.min_size = RuleSize(0, 0)

    def T__4(self, parent=None):
        with UnlexerRuleContext(self, 'T__4', parent) as current:
            current.src += 'end'
            return current
    T__4.min_size = RuleSize(0, 0)

    def T__5(self, parent=None):
        with UnlexerRuleContext(self, 'T__5', parent) as current:
            current.src += 'while'
            return current
    T__5.min_size = RuleSize(0, 0)

    def T__6(self, parent=None):
        with UnlexerRuleContext(self, 'T__6', parent) as current:
            current.src += 'repeat'
            return current
    T__6.min_size = RuleSize(0, 0)

    def T__7(self, parent=None):
        with UnlexerRuleContext(self, 'T__7', parent) as current:
            current.src += 'until'
            return current
    T__7.min_size = RuleSize(0, 0)

    def T__8(self, parent=None):
        with UnlexerRuleContext(self, 'T__8', parent) as current:
            current.src += 'if'
            return current
    T__8.min_size = RuleSize(0, 0)

    def T__9(self, parent=None):
        with UnlexerRuleContext(self, 'T__9', parent) as current:
            current.src += 'then'
            return current
    T__9.min_size = RuleSize(0, 0)

    def T__10(self, parent=None):
        with UnlexerRuleContext(self, 'T__10', parent) as current:
            current.src += 'elseif'
            return current
    T__10.min_size = RuleSize(0, 0)

    def T__11(self, parent=None):
        with UnlexerRuleContext(self, 'T__11', parent) as current:
            current.src += 'else'
            return current
    T__11.min_size = RuleSize(0, 0)

    def T__12(self, parent=None):
        with UnlexerRuleContext(self, 'T__12', parent) as current:
            current.src += 'for'
            return current
    T__12.min_size = RuleSize(0, 0)

    def T__13(self, parent=None):
        with UnlexerRuleContext(self, 'T__13', parent) as current:
            current.src += ','
            return current
    T__13.min_size = RuleSize(0, 0)

    def T__14(self, parent=None):
        with UnlexerRuleContext(self, 'T__14', parent) as current:
            current.src += 'in'
            return current
    T__14.min_size = RuleSize(0, 0)

    def T__15(self, parent=None):
        with UnlexerRuleContext(self, 'T__15', parent) as current:
            current.src += 'function'
            return current
    T__15.min_size = RuleSize(0, 0)

    def T__16(self, parent=None):
        with UnlexerRuleContext(self, 'T__16', parent) as current:
            current.src += 'local'
            return current
    T__16.min_size = RuleSize(0, 0)

    def T__17(self, parent=None):
        with UnlexerRuleContext(self, 'T__17', parent) as current:
            current.src += '<'
            return current
    T__17.min_size = RuleSize(0, 0)

    def T__18(self, parent=None):
        with UnlexerRuleContext(self, 'T__18', parent) as current:
            current.src += 'const'
            return current
    T__18.min_size = RuleSize(0, 0)

    def T__19(self, parent=None):
        with UnlexerRuleContext(self, 'T__19', parent) as current:
            current.src += 'close'
            return current
    T__19.min_size = RuleSize(0, 0)

    def T__20(self, parent=None):
        with UnlexerRuleContext(self, 'T__20', parent) as current:
            current.src += '>'
            return current
    T__20.min_size = RuleSize(0, 0)

    def T__21(self, parent=None):
        with UnlexerRuleContext(self, 'T__21', parent) as current:
            current.src += 'return'
            return current
    T__21.min_size = RuleSize(0, 0)

    def T__22(self, parent=None):
        with UnlexerRuleContext(self, 'T__22', parent) as current:
            current.src += '::'
            return current
    T__22.min_size = RuleSize(0, 0)

    def T__23(self, parent=None):
        with UnlexerRuleContext(self, 'T__23', parent) as current:
            current.src += '.'
            return current
    T__23.min_size = RuleSize(0, 0)

    def T__24(self, parent=None):
        with UnlexerRuleContext(self, 'T__24', parent) as current:
            current.src += ':'
            return current
    T__24.min_size = RuleSize(0, 0)

    def T__25(self, parent=None):
        with UnlexerRuleContext(self, 'T__25', parent) as current:
            current.src += 'nil'
            return current
    T__25.min_size = RuleSize(0, 0)

    def T__26(self, parent=None):
        with UnlexerRuleContext(self, 'T__26', parent) as current:
            current.src += 'false'
            return current
    T__26.min_size = RuleSize(0, 0)

    def T__27(self, parent=None):
        with UnlexerRuleContext(self, 'T__27', parent) as current:
            current.src += 'true'
            return current
    T__27.min_size = RuleSize(0, 0)

    def T__28(self, parent=None):
        with UnlexerRuleContext(self, 'T__28', parent) as current:
            current.src += '('
            return current
    T__28.min_size = RuleSize(0, 0)

    def T__29(self, parent=None):
        with UnlexerRuleContext(self, 'T__29', parent) as current:
            current.src += ')'
            return current
    T__29.min_size = RuleSize(0, 0)

    def T__30(self, parent=None):
        with UnlexerRuleContext(self, 'T__30', parent) as current:
            current.src += '['
            return current
    T__30.min_size = RuleSize(0, 0)

    def T__31(self, parent=None):
        with UnlexerRuleContext(self, 'T__31', parent) as current:
            current.src += ']'
            return current
    T__31.min_size = RuleSize(0, 0)

    def T__32(self, parent=None):
        with UnlexerRuleContext(self, 'T__32', parent) as current:
            current.src += '...'
            return current
    T__32.min_size = RuleSize(0, 0)

    def T__33(self, parent=None):
        with UnlexerRuleContext(self, 'T__33', parent) as current:
            current.src += '{'
            return current
    T__33.min_size = RuleSize(0, 0)

    def T__34(self, parent=None):
        with UnlexerRuleContext(self, 'T__34', parent) as current:
            current.src += '}'
            return current
    T__34.min_size = RuleSize(0, 0)

    def T__35(self, parent=None):
        with UnlexerRuleContext(self, 'T__35', parent) as current:
            current.src += 'or'
            return current
    T__35.min_size = RuleSize(0, 0)

    def T__36(self, parent=None):
        with UnlexerRuleContext(self, 'T__36', parent) as current:
            current.src += 'and'
            return current
    T__36.min_size = RuleSize(0, 0)

    def T__37(self, parent=None):
        with UnlexerRuleContext(self, 'T__37', parent) as current:
            current.src += '<='
            return current
    T__37.min_size = RuleSize(0, 0)

    def T__38(self, parent=None):
        with UnlexerRuleContext(self, 'T__38', parent) as current:
            current.src += '>='
            return current
    T__38.min_size = RuleSize(0, 0)

    def T__39(self, parent=None):
        with UnlexerRuleContext(self, 'T__39', parent) as current:
            current.src += '~='
            return current
    T__39.min_size = RuleSize(0, 0)

    def T__40(self, parent=None):
        with UnlexerRuleContext(self, 'T__40', parent) as current:
            current.src += '=='
            return current
    T__40.min_size = RuleSize(0, 0)

    def T__41(self, parent=None):
        with UnlexerRuleContext(self, 'T__41', parent) as current:
            current.src += '..'
            return current
    T__41.min_size = RuleSize(0, 0)

    def T__42(self, parent=None):
        with UnlexerRuleContext(self, 'T__42', parent) as current:
            current.src += '+'
            return current
    T__42.min_size = RuleSize(0, 0)

    def T__43(self, parent=None):
        with UnlexerRuleContext(self, 'T__43', parent) as current:
            current.src += '-'
            return current
    T__43.min_size = RuleSize(0, 0)

    def T__44(self, parent=None):
        with UnlexerRuleContext(self, 'T__44', parent) as current:
            current.src += '*'
            return current
    T__44.min_size = RuleSize(0, 0)

    def T__45(self, parent=None):
        with UnlexerRuleContext(self, 'T__45', parent) as current:
            current.src += '/'
            return current
    T__45.min_size = RuleSize(0, 0)

    def T__46(self, parent=None):
        with UnlexerRuleContext(self, 'T__46', parent) as current:
            current.src += '%'
            return current
    T__46.min_size = RuleSize(0, 0)

    def T__47(self, parent=None):
        with UnlexerRuleContext(self, 'T__47', parent) as current:
            current.src += '//'
            return current
    T__47.min_size = RuleSize(0, 0)

    def T__48(self, parent=None):
        with UnlexerRuleContext(self, 'T__48', parent) as current:
            current.src += '&'
            return current
    T__48.min_size = RuleSize(0, 0)

    def T__49(self, parent=None):
        with UnlexerRuleContext(self, 'T__49', parent) as current:
            current.src += '|'
            return current
    T__49.min_size = RuleSize(0, 0)

    def T__50(self, parent=None):
        with UnlexerRuleContext(self, 'T__50', parent) as current:
            current.src += '~'
            return current
    T__50.min_size = RuleSize(0, 0)

    def T__51(self, parent=None):
        with UnlexerRuleContext(self, 'T__51', parent) as current:
            current.src += '<<'
            return current
    T__51.min_size = RuleSize(0, 0)

    def T__52(self, parent=None):
        with UnlexerRuleContext(self, 'T__52', parent) as current:
            current.src += '>>'
            return current
    T__52.min_size = RuleSize(0, 0)

    def T__53(self, parent=None):
        with UnlexerRuleContext(self, 'T__53', parent) as current:
            current.src += 'not'
            return current
    T__53.min_size = RuleSize(0, 0)

    def T__54(self, parent=None):
        with UnlexerRuleContext(self, 'T__54', parent) as current:
            current.src += '#'
            return current
    T__54.min_size = RuleSize(0, 0)

    def T__55(self, parent=None):
        with UnlexerRuleContext(self, 'T__55', parent) as current:
            current.src += '^'
            return current
    T__55.min_size = RuleSize(0, 0)

    _default_rule = chunk

    _charsets = {
        0: list(itertools.chain.from_iterable([range(0x20, 0x7f)])),
        1: list(itertools.chain.from_iterable([range(0x41, 0x5b), range(0x5f, 0x60), range(0x61, 0x7b)])),
        2: list(itertools.chain.from_iterable([range(0x30, 0x3a), range(0x41, 0x5b), range(0x5f, 0x60), range(0x61, 0x7b)])),
        3: list(itertools.chain.from_iterable([range(0x20, 0x22), range(0x23, 0x5c), range(0x5d, 0x7f)])),
        4: list(itertools.chain.from_iterable([range(0x58, 0x59), range(0x78, 0x79)])),
        5: list(itertools.chain.from_iterable([range(0x45, 0x46), range(0x65, 0x66)])),
        6: list(itertools.chain.from_iterable([range(0x2b, 0x2c), range(0x2d, 0x2e)])),
        7: list(itertools.chain.from_iterable([range(0x50, 0x51), range(0x70, 0x71)])),
        8: list(itertools.chain.from_iterable([range(0x22, 0x23), range(0x5c, 0x5d), range(0x61, 0x62), range(0x62, 0x63), range(0x66, 0x67), range(0x6e, 0x6f), range(0x72, 0x73), range(0x74, 0x75), range(0x76, 0x77), range(0x7a, 0x7b)])),
        9: list(itertools.chain.from_iterable([range(0x30, 0x33)])),
        10: list(itertools.chain.from_iterable([range(0x30, 0x35)])),
        11: list(itertools.chain.from_iterable([range(0x30, 0x3a)])),
        12: list(itertools.chain.from_iterable([range(0x30, 0x3a), range(0x41, 0x47), range(0x61, 0x67)])),
        13: list(itertools.chain.from_iterable([range(0x9, 0xa), range(0xa, 0xb), range(0xc, 0xd), range(0xd, 0xe), range(0x20, 0x21)])),
    }
