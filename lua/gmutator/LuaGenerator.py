# Generated by Grammarinator 19.3.post165+gf23ccaf

import itertools

from math import inf
from grammarinator.runtime import *

class LuaGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    def chunk(self, parent=None):
        with RuleContext(self, UnparserRule(name='chunk', parent=parent)) as current:
            self.block(parent=current)
            self.EOF(parent=current)
            return current
    chunk.min_depth = 2

    def block(self, parent=None):
        with RuleContext(self, UnparserRule(name='block', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.stat(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    self.laststat(parent=current)
            return current
    block.min_depth = 1

    def blockLoop(self, parent=None):
        with RuleContext(self, UnparserRule(name='blockLoop', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.statLoop(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    self.laststatLoop(parent=current)
            return current
    blockLoop.min_depth = 1

    def statLoop(self, parent=None):
        with RuleContext(self, UnparserRule(name='statLoop', parent=parent)) as current:
            with AlternationContext(self, [0, 3, 3, 2, 0, 2, 2, 1, 2, 2, 2, 3, 3, 2], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src=';', parent=current)
                elif choice0 == 1:
                    self.varlist(parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.explist(parent=current)
                elif choice0 == 2:
                    self.functioncall(parent=current)
                elif choice0 == 3:
                    self.label(parent=current)
                elif choice0 == 4:
                    UnlexerRule(src='break', parent=current)
                elif choice0 == 5:
                    UnlexerRule(src='do', parent=current)
                    self.blockLoop(parent=current)
                    UnlexerRule(src='end', parent=current)
                elif choice0 == 6:
                    UnlexerRule(src='while', parent=current)
                    self.exp(parent=current)
                    UnlexerRule(src='do', parent=current)
                    self.blockLoop(parent=current)
                    UnlexerRule(src='end', parent=current)
                elif choice0 == 7:
                    UnlexerRule(src='repeat', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 0, min=1, max=inf):
                            self.statLoop(parent=current)
                    if self._max_depth >= 1:
                        for _ in self._model.quantify(current, 1, min=0, max=1):
                            self.laststatB(parent=current)
                    UnlexerRule(src='until', parent=current)
                    self.exp(parent=current)
                elif choice0 == 8:
                    UnlexerRule(src='if', parent=current)
                    self.exp(parent=current)
                    UnlexerRule(src='then', parent=current)
                    self.blockLoop(parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 2, min=0, max=inf):
                            UnlexerRule(src='elseif', parent=current)
                            self.exp(parent=current)
                            UnlexerRule(src='then', parent=current)
                            self.blockLoop(parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 3, min=0, max=1):
                            UnlexerRule(src='else', parent=current)
                            self.blockLoop(parent=current)
                    UnlexerRule(src='end', parent=current)
                elif choice0 == 9:
                    UnlexerRule(src='for', parent=current)
                    self.NAME(parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.exp(parent=current)
                    UnlexerRule(src=',', parent=current)
                    self.exp(parent=current)
                    if self._max_depth >= 1:
                        for _ in self._model.quantify(current, 4, min=0, max=1):
                            UnlexerRule(src=',', parent=current)
                            self.exp(parent=current)
                    UnlexerRule(src='do', parent=current)
                    self.blockLoop(parent=current)
                    UnlexerRule(src='end', parent=current)
                elif choice0 == 10:
                    UnlexerRule(src='for', parent=current)
                    self.namelist(parent=current)
                    UnlexerRule(src='in', parent=current)
                    self.explist(parent=current)
                    UnlexerRule(src='do', parent=current)
                    self.blockLoop(parent=current)
                    UnlexerRule(src='end', parent=current)
                elif choice0 == 11:
                    UnlexerRule(src='function', parent=current)
                    self.funcname(parent=current)
                    self.funcbody(parent=current)
                elif choice0 == 12:
                    UnlexerRule(src='local', parent=current)
                    UnlexerRule(src='function', parent=current)
                    self.NAME(parent=current)
                    self.funcbody(parent=current)
                elif choice0 == 13:
                    UnlexerRule(src='local', parent=current)
                    self.attnamelist(parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 5, min=0, max=1):
                            UnlexerRule(src='=', parent=current)
                            self.explist(parent=current)
            return current
    statLoop.min_depth = 0

    def stat(self, parent=None):
        with RuleContext(self, UnparserRule(name='stat', parent=parent)) as current:
            with AlternationContext(self, [0, 3, 3, 2, 2, 2, 1, 2, 2, 2, 3, 3, 2], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src=';', parent=current)
                elif choice0 == 1:
                    self.varlist(parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.explist(parent=current)
                elif choice0 == 2:
                    self.functioncall(parent=current)
                elif choice0 == 3:
                    self.label(parent=current)
                elif choice0 == 4:
                    UnlexerRule(src='do', parent=current)
                    self.block(parent=current)
                    UnlexerRule(src='end', parent=current)
                elif choice0 == 5:
                    UnlexerRule(src='while', parent=current)
                    self.exp(parent=current)
                    UnlexerRule(src='do', parent=current)
                    self.blockLoop(parent=current)
                    UnlexerRule(src='end', parent=current)
                elif choice0 == 6:
                    UnlexerRule(src='repeat', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 0, min=1, max=inf):
                            self.statLoop(parent=current)
                    if self._max_depth >= 1:
                        for _ in self._model.quantify(current, 1, min=0, max=1):
                            self.laststatB(parent=current)
                    UnlexerRule(src='until', parent=current)
                    self.exp(parent=current)
                elif choice0 == 7:
                    UnlexerRule(src='if', parent=current)
                    self.exp(parent=current)
                    UnlexerRule(src='then', parent=current)
                    self.block(parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 2, min=0, max=inf):
                            UnlexerRule(src='elseif', parent=current)
                            self.exp(parent=current)
                            UnlexerRule(src='then', parent=current)
                            self.block(parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 3, min=0, max=1):
                            UnlexerRule(src='else', parent=current)
                            self.block(parent=current)
                    UnlexerRule(src='end', parent=current)
                elif choice0 == 8:
                    UnlexerRule(src='for', parent=current)
                    self.NAME(parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.exp(parent=current)
                    UnlexerRule(src=',', parent=current)
                    self.exp(parent=current)
                    if self._max_depth >= 1:
                        for _ in self._model.quantify(current, 4, min=0, max=1):
                            UnlexerRule(src=',', parent=current)
                            self.exp(parent=current)
                    UnlexerRule(src='do', parent=current)
                    self.blockLoop(parent=current)
                    UnlexerRule(src='end', parent=current)
                elif choice0 == 9:
                    UnlexerRule(src='for', parent=current)
                    self.namelist(parent=current)
                    UnlexerRule(src='in', parent=current)
                    self.explist(parent=current)
                    UnlexerRule(src='do', parent=current)
                    self.blockLoop(parent=current)
                    UnlexerRule(src='end', parent=current)
                elif choice0 == 10:
                    UnlexerRule(src='function', parent=current)
                    self.funcname(parent=current)
                    self.funcbody(parent=current)
                elif choice0 == 11:
                    UnlexerRule(src='local', parent=current)
                    UnlexerRule(src='function', parent=current)
                    self.NAME(parent=current)
                    self.funcbody(parent=current)
                elif choice0 == 12:
                    UnlexerRule(src='local', parent=current)
                    self.attnamelist(parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 5, min=0, max=1):
                            UnlexerRule(src='=', parent=current)
                            self.explist(parent=current)
            return current
    stat.min_depth = 0

    def attnamelist(self, parent=None):
        with RuleContext(self, UnparserRule(name='attnamelist', parent=parent)) as current:
            self.attrclose = 1
            self.NAME(parent=current)
            self.attrib(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 1, min=0, max=inf):
                            UnlexerRule(src=',', parent=current)
                    self.NAME(parent=current)
                    self.attrib(parent=current)
            return current
    attnamelist.min_depth = 1

    def attrib(self, parent=None):
        with RuleContext(self, UnparserRule(name='attrib', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='<', parent=current)
                    with AlternationContext(self, [0, 0], [1, self.attrclose]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        if choice0 == 0:
                            UnlexerRule(src='const', parent=current)
                        elif choice0 == 1:
                            UnlexerRule(src='close', parent=current)
                            self.attrclose = 0
                    UnlexerRule(src='>', parent=current)
            return current
    attrib.min_depth = 0

    def laststatLoop(self, parent=None):
        with RuleContext(self, UnparserRule(name='laststatLoop', parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src='return', parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 0, min=0, max=1):
                            self.explist(parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='break', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src=';', parent=current)
            return current
    laststatLoop.min_depth = 0

    def laststatB(self, parent=None):
        with RuleContext(self, UnparserRule(name='laststatB', parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src='return', parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 0, min=0, max=1):
                            self.explist(parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='break', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src=';', parent=current)
            return current
    laststatB.min_depth = 0

    def laststat(self, parent=None):
        with RuleContext(self, UnparserRule(name='laststat', parent=parent)) as current:
            UnlexerRule(src='return', parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.explist(parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src=';', parent=current)
            return current
    laststat.min_depth = 0

    def label(self, parent=None):
        with RuleContext(self, UnparserRule(name='label', parent=parent)) as current:
            UnlexerRule(src='::', parent=current)
            self.NAME(parent=current)
            UnlexerRule(src='::', parent=current)
            return current
    label.min_depth = 1

    def funcname(self, parent=None):
        with RuleContext(self, UnparserRule(name='funcname', parent=parent)) as current:
            self.NAME(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src='.', parent=current)
                    self.NAME(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src=':', parent=current)
                    self.NAME(parent=current)
            return current
    funcname.min_depth = 1

    def varlist(self, parent=None):
        with RuleContext(self, UnparserRule(name='varlist', parent=parent)) as current:
            self.var(parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.var(parent=current)
            return current
    varlist.min_depth = 2

    def namelist(self, parent=None):
        with RuleContext(self, UnparserRule(name='namelist', parent=parent)) as current:
            self.NAME(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.NAME(parent=current)
            return current
    namelist.min_depth = 1

    def explist(self, parent=None):
        with RuleContext(self, UnparserRule(name='explist', parent=parent)) as current:
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.exp(parent=current)
                    UnlexerRule(src=',', parent=current)
            self.exp(parent=current)
            return current
    explist.min_depth = 1

    def exp(self, parent=None):
        with RuleContext(self, UnparserRule(name='exp', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 3, 2, 4, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src='nil', parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='false', parent=current)
                elif choice0 == 2:
                    UnlexerRule(src='true', parent=current)
                elif choice0 == 3:
                    self.number(parent=current)
                elif choice0 == 4:
                    self.string(parent=current)
                elif choice0 == 5:
                    self.functiondef(parent=current)
                elif choice0 == 6:
                    self.prefixexp(parent=current)
                elif choice0 == 7:
                    self.tableconstructor(parent=current)
                elif choice0 == 8:
                    self.exp(parent=current)
                    self.operatorPower(parent=current)
                    self.exp(parent=current)
                elif choice0 == 9:
                    self.operatorUnary(parent=current)
                    self.exp(parent=current)
                elif choice0 == 10:
                    self.exp(parent=current)
                    self.operatorMulDivMod(parent=current)
                    self.exp(parent=current)
                elif choice0 == 11:
                    self.exp(parent=current)
                    self.operatorAddSub(parent=current)
                    self.exp(parent=current)
                elif choice0 == 12:
                    self.exp(parent=current)
                    self.operatorStrcat(parent=current)
                    self.exp(parent=current)
                elif choice0 == 13:
                    self.exp(parent=current)
                    self.operatorComparison(parent=current)
                    self.exp(parent=current)
                elif choice0 == 14:
                    self.exp(parent=current)
                    self.operatorAnd(parent=current)
                    self.exp(parent=current)
                elif choice0 == 15:
                    self.exp(parent=current)
                    self.operatorOr(parent=current)
                    self.exp(parent=current)
                elif choice0 == 16:
                    self.exp(parent=current)
                    self.operatorBitwise(parent=current)
                    self.exp(parent=current)
            return current
    exp.min_depth = 0

    def prefixexp(self, parent=None):
        with RuleContext(self, UnparserRule(name='prefixexp', parent=parent)) as current:
            self.varOrExp(parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.nameAndArgs(parent=current)
            return current
    prefixexp.min_depth = 2

    def functioncall(self, parent=None):
        with RuleContext(self, UnparserRule(name='functioncall', parent=parent)) as current:
            self.varOrExp(parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.nameAndArgs(parent=current)
            return current
    functioncall.min_depth = 2

    def varOrExp(self, parent=None):
        with RuleContext(self, UnparserRule(name='varOrExp', parent=parent)) as current:
            with AlternationContext(self, [2, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.var(parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='(', parent=current)
                    self.exp(parent=current)
                    UnlexerRule(src=')', parent=current)
            return current
    varOrExp.min_depth = 1

    def var(self, parent=None):
        with RuleContext(self, UnparserRule(name='var', parent=parent)) as current:
            with AlternationContext(self, [1, 2], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.NAME(parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='(', parent=current)
                    self.exp(parent=current)
                    UnlexerRule(src=')', parent=current)
                    self.varSuffix(parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.varSuffix(parent=current)
            return current
    var.min_depth = 1

    def varSuffix(self, parent=None):
        with RuleContext(self, UnparserRule(name='varSuffix', parent=parent)) as current:
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.nameAndArgs(parent=current)
            with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src='[', parent=current)
                    self.exp(parent=current)
                    UnlexerRule(src=']', parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='.', parent=current)
                    self.NAME(parent=current)
            return current
    varSuffix.min_depth = 1

    def nameAndArgs(self, parent=None):
        with RuleContext(self, UnparserRule(name='nameAndArgs', parent=parent)) as current:
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src=':', parent=current)
                    self.NAME(parent=current)
            self.args(parent=current)
            return current
    nameAndArgs.min_depth = 1

    def args(self, parent=None):
        with RuleContext(self, UnparserRule(name='args', parent=parent)) as current:
            with AlternationContext(self, [0, 1, 2], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src='(', parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 0, min=0, max=1):
                            self.explist(parent=current)
                    UnlexerRule(src=')', parent=current)
                elif choice0 == 1:
                    self.tableconstructor(parent=current)
                elif choice0 == 2:
                    self.string(parent=current)
            return current
    args.min_depth = 0

    def functiondef(self, parent=None):
        with RuleContext(self, UnparserRule(name='functiondef', parent=parent)) as current:
            UnlexerRule(src='function', parent=current)
            self.funcbody(parent=current)
            return current
    functiondef.min_depth = 3

    def funcbody(self, parent=None):
        with RuleContext(self, UnparserRule(name='funcbody', parent=parent)) as current:
            UnlexerRule(src='(', parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.parlist(parent=current)
            UnlexerRule(src=')', parent=current)
            self.block(parent=current)
            UnlexerRule(src='end', parent=current)
            return current
    funcbody.min_depth = 2

    def parlist(self, parent=None):
        with RuleContext(self, UnparserRule(name='parlist', parent=parent)) as current:
            with AlternationContext(self, [2, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.namelist(parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 0, min=0, max=1):
                            UnlexerRule(src=',', parent=current)
                            UnlexerRule(src='...', parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='...', parent=current)
            return current
    parlist.min_depth = 0

    def tableconstructor(self, parent=None):
        with RuleContext(self, UnparserRule(name='tableconstructor', parent=parent)) as current:
            UnlexerRule(src='{', parent=current)
            if self._max_depth >= 3:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.fieldlist(parent=current)
            UnlexerRule(src='}', parent=current)
            return current
    tableconstructor.min_depth = 0

    def fieldlist(self, parent=None):
        with RuleContext(self, UnparserRule(name='fieldlist', parent=parent)) as current:
            self.field(parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.fieldsep(parent=current)
                    self.field(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    self.fieldsep(parent=current)
            return current
    fieldlist.min_depth = 2

    def field(self, parent=None):
        with RuleContext(self, UnparserRule(name='field', parent=parent)) as current:
            with AlternationContext(self, [1, 1, 1], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src='[', parent=current)
                    self.exp(parent=current)
                    UnlexerRule(src=']', parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.exp(parent=current)
                elif choice0 == 1:
                    self.NAME(parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.exp(parent=current)
                elif choice0 == 2:
                    self.exp(parent=current)
            return current
    field.min_depth = 1

    def fieldsep(self, parent=None):
        with RuleContext(self, UnparserRule(name='fieldsep', parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=[',', ';'][choice0], parent=current)
            return current
    fieldsep.min_depth = 0

    def operatorOr(self, parent=None):
        with RuleContext(self, UnparserRule(name='operatorOr', parent=parent)) as current:
            UnlexerRule(src='or', parent=current)
            return current
    operatorOr.min_depth = 0

    def operatorAnd(self, parent=None):
        with RuleContext(self, UnparserRule(name='operatorAnd', parent=parent)) as current:
            UnlexerRule(src='and', parent=current)
            return current
    operatorAnd.min_depth = 0

    def operatorComparison(self, parent=None):
        with RuleContext(self, UnparserRule(name='operatorComparison', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['<', '>', '<=', '>=', '~=', '=='][choice0], parent=current)
            return current
    operatorComparison.min_depth = 0

    def operatorStrcat(self, parent=None):
        with RuleContext(self, UnparserRule(name='operatorStrcat', parent=parent)) as current:
            UnlexerRule(src='..', parent=current)
            return current
    operatorStrcat.min_depth = 0

    def operatorAddSub(self, parent=None):
        with RuleContext(self, UnparserRule(name='operatorAddSub', parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['+', '-'][choice0], parent=current)
            return current
    operatorAddSub.min_depth = 0

    def operatorMulDivMod(self, parent=None):
        with RuleContext(self, UnparserRule(name='operatorMulDivMod', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0], [1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['*', '/', '%', '//'][choice0], parent=current)
            return current
    operatorMulDivMod.min_depth = 0

    def operatorBitwise(self, parent=None):
        with RuleContext(self, UnparserRule(name='operatorBitwise', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0, 0], [1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['&', '|', '~', '<<', '>>'][choice0], parent=current)
            return current
    operatorBitwise.min_depth = 0

    def operatorUnary(self, parent=None):
        with RuleContext(self, UnparserRule(name='operatorUnary', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0], [1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['not', '#', '-', '~'][choice0], parent=current)
            return current
    operatorUnary.min_depth = 0

    def operatorPower(self, parent=None):
        with RuleContext(self, UnparserRule(name='operatorPower', parent=parent)) as current:
            UnlexerRule(src='^', parent=current)
            return current
    operatorPower.min_depth = 0

    def number(self, parent=None):
        with RuleContext(self, UnparserRule(name='number', parent=parent)) as current:
            with AlternationContext(self, [2, 2, 2, 2], [1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.INT, self.HEX, self.FLOAT, self.HEX_FLOAT][choice0](parent=current)
            return current
    number.min_depth = 2

    def string(self, parent=None):
        with RuleContext(self, UnparserRule(name='string', parent=parent)) as current:
            with AlternationContext(self, [1, 1, 2], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.NORMALSTRING, self.CHARSTRING, self.LONGSTRING][choice0](parent=current)
            return current
    string.min_depth = 1

    def NAME(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NAME', parent=parent)) as current:
            UnlexerRule(src='name_', parent=current)
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[1]), parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=self._model.charset(current, 1, self._charsets[2]), parent=current)
            return current
    NAME.min_depth = 0

    def NORMALSTRING(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NORMALSTRING', parent=parent)) as current:
            UnlexerRule(src='"', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    with AlternationContext(self, [1, 0], [1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        if choice0 == 0:
                            self.EscapeSequence(parent=current)
                        elif choice0 == 1:
                            UnlexerRule(src=self._model.charset(current, 0, self._charsets[3]), parent=current)
            UnlexerRule(src='"', parent=current)
            return current
    NORMALSTRING.min_depth = 0

    def CHARSTRING(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CHARSTRING', parent=parent)) as current:
            UnlexerRule(src='\'', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    with AlternationContext(self, [1, 0, 0], [1, 1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        if choice0 == 0:
                            self.EscapeSequence(parent=current)
                        elif choice0 == 1:
                            UnlexerRule(src=self._model.charset(current, 0, self._charsets[4]), parent=current)
                        elif choice0 == 2:
                            UnlexerRule(src=self._model.charset(current, 1, self._charsets[5]), parent=current)
                            UnlexerRule(src=self._model.charset(current, 2, self._charsets[6]), parent=current)
            UnlexerRule(src='\'', parent=current)
            return current
    CHARSTRING.min_depth = 0

    def LONGSTRING(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LONGSTRING', parent=parent)) as current:
            UnlexerRule(src='[', parent=current)
            self.NESTED_STR(parent=current)
            UnlexerRule(src=']', parent=current)
            return current
    LONGSTRING.min_depth = 1

    def NESTED_STR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NESTED_STR', parent=parent)) as current:
            with AlternationContext(self, [1, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src='=', parent=current)
                    self.NESTED_STR(parent=current)
                    UnlexerRule(src='=', parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='=[', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 0, min=0, max=inf):
                            UnlexerRule(src=self._model.charset(current, 0, self._charsets[0]), parent=current)
                    UnlexerRule(src=']=', parent=current)
            return current
    NESTED_STR.min_depth = 0

    def INT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='INT', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.Digit(parent=current)
            return current
    INT.min_depth = 1

    def HEX(self, parent=None):
        with RuleContext(self, UnlexerRule(name='HEX', parent=parent)) as current:
            UnlexerRule(src='0', parent=current)
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[7]), parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.HexDigit(parent=current)
            return current
    HEX.min_depth = 1

    def FLOAT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FLOAT', parent=parent)) as current:
            with AlternationContext(self, [1, 1, 2], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 0, min=1, max=inf):
                            self.Digit(parent=current)
                    UnlexerRule(src='.', parent=current)
                    if self._max_depth >= 1:
                        for _ in self._model.quantify(current, 1, min=0, max=inf):
                            self.Digit(parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 2, min=0, max=1):
                            self.ExponentPart(parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='.', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 3, min=1, max=inf):
                            self.Digit(parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 4, min=0, max=1):
                            self.ExponentPart(parent=current)
                elif choice0 == 2:
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 5, min=1, max=inf):
                            self.Digit(parent=current)
                    self.ExponentPart(parent=current)
            return current
    FLOAT.min_depth = 1

    def HEX_FLOAT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='HEX_FLOAT', parent=parent)) as current:
            with AlternationContext(self, [1, 1, 2], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src='0', parent=current)
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[8]), parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 0, min=1, max=inf):
                            self.HexDigit(parent=current)
                    UnlexerRule(src='.', parent=current)
                    if self._max_depth >= 1:
                        for _ in self._model.quantify(current, 1, min=0, max=inf):
                            self.HexDigit(parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 2, min=0, max=1):
                            self.HexExponentPart(parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='0', parent=current)
                    UnlexerRule(src=self._model.charset(current, 1, self._charsets[9]), parent=current)
                    UnlexerRule(src='.', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 3, min=1, max=inf):
                            self.HexDigit(parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 4, min=0, max=1):
                            self.HexExponentPart(parent=current)
                elif choice0 == 2:
                    UnlexerRule(src='0', parent=current)
                    UnlexerRule(src=self._model.charset(current, 2, self._charsets[10]), parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 5, min=1, max=inf):
                            self.HexDigit(parent=current)
                    self.HexExponentPart(parent=current)
            return current
    HEX_FLOAT.min_depth = 1

    def ExponentPart(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ExponentPart', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[11]), parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src=self._model.charset(current, 1, self._charsets[12]), parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 1, min=1, max=inf):
                    self.Digit(parent=current)
            return current
    ExponentPart.min_depth = 1

    def HexExponentPart(self, parent=None):
        with RuleContext(self, UnlexerRule(name='HexExponentPart', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[13]), parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src=self._model.charset(current, 1, self._charsets[14]), parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 1, min=1, max=inf):
                    self.Digit(parent=current)
            return current
    HexExponentPart.min_depth = 1

    def EscapeSequence(self, parent=None):
        with RuleContext(self, UnlexerRule(name='EscapeSequence', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 2, 2, 2], [1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src='\\', parent=current)
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[15]), parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='\\', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 0, min=0, max=1):
                            UnlexerRule(src='\r', parent=current)
                    UnlexerRule(src='\n', parent=current)
                elif choice0 == 2:
                    self.DecimalEscape(parent=current)
                elif choice0 == 3:
                    self.HexEscape(parent=current)
                elif choice0 == 4:
                    self.UtfEscape(parent=current)
            return current
    EscapeSequence.min_depth = 0

    def DecimalEscape(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DecimalEscape', parent=parent)) as current:
            with AlternationContext(self, [1, 1, 1], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src='\\', parent=current)
                    self.Digit(parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='\\', parent=current)
                    self.Digit(parent=current)
                    self.Digit(parent=current)
                elif choice0 == 2:
                    UnlexerRule(src='\\', parent=current)
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[16]), parent=current)
                    UnlexerRule(src=self._model.charset(current, 1, self._charsets[17]), parent=current)
                    self.Digit(parent=current)
            return current
    DecimalEscape.min_depth = 1

    def HexEscape(self, parent=None):
        with RuleContext(self, UnlexerRule(name='HexEscape', parent=parent)) as current:
            UnlexerRule(src='\\', parent=current)
            UnlexerRule(src='x', parent=current)
            self.HexDigit(parent=current)
            self.HexDigit(parent=current)
            return current
    HexEscape.min_depth = 1

    def UtfEscape(self, parent=None):
        with RuleContext(self, UnlexerRule(name='UtfEscape', parent=parent)) as current:
            UnlexerRule(src='\\', parent=current)
            UnlexerRule(src='u{', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.HexDigit(parent=current)
            UnlexerRule(src='}', parent=current)
            return current
    UtfEscape.min_depth = 1

    def Digit(self, parent=None):
        with RuleContext(self, UnlexerRule(name='Digit', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[18]), parent=current)
            return current
    Digit.min_depth = 0

    def HexDigit(self, parent=None):
        with RuleContext(self, UnlexerRule(name='HexDigit', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[19]), parent=current)
            return current
    HexDigit.min_depth = 0

    def SingleLineInputCharacter(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SingleLineInputCharacter', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[20]), parent=current)
            return current
    SingleLineInputCharacter.min_depth = 0

    def COMMENT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COMMENT', parent=parent)) as current:
            UnlexerRule(src='--[', parent=current)
            self.NESTED_STR(parent=current)
            UnlexerRule(src=']', parent=current)
            return current
    COMMENT.min_depth = 1

    def LINE_COMMENT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LINE_COMMENT', parent=parent)) as current:
            UnlexerRule(src='--', parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.SingleLineInputCharacter(parent=current)
            return current
    LINE_COMMENT.min_depth = 0

    def WS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='WS', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[21]), parent=current)
            return current
    WS.min_depth = 0

    def SHEBANG(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SHEBANG', parent=parent)) as current:
            UnlexerRule(src='#', parent=current)
            UnlexerRule(src='!', parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.SingleLineInputCharacter(parent=current)
            return current
    SHEBANG.min_depth = 0

    _default_rule = chunk

    _charsets = {
        0: list(itertools.chain.from_iterable([range(32, 127)])),
        1: list(itertools.chain.from_iterable([range(65, 91), range(95, 96), range(97, 123)])),
        2: list(itertools.chain.from_iterable([range(48, 58), range(65, 91), range(95, 96), range(97, 123)])),
        3: list(itertools.chain.from_iterable([range(32, 34), range(35, 92), range(93, 127)])),
        4: list(itertools.chain.from_iterable([range(48, 58), range(65, 91), range(95, 96), range(97, 123)])),
        5: list(itertools.chain.from_iterable([range(48, 58), range(65, 91), range(95, 96), range(97, 123)])),
        6: list(itertools.chain.from_iterable([range(48, 58), range(65, 91), range(95, 96), range(97, 123)])),
        7: list(itertools.chain.from_iterable([range(88, 89), range(120, 121)])),
        8: list(itertools.chain.from_iterable([range(88, 89), range(120, 121)])),
        9: list(itertools.chain.from_iterable([range(88, 89), range(120, 121)])),
        10: list(itertools.chain.from_iterable([range(88, 89), range(120, 121)])),
        11: list(itertools.chain.from_iterable([range(69, 70), range(101, 102)])),
        12: list(itertools.chain.from_iterable([range(43, 44), range(45, 46)])),
        13: list(itertools.chain.from_iterable([range(80, 81), range(112, 113)])),
        14: list(itertools.chain.from_iterable([range(43, 44), range(45, 46)])),
        15: list(itertools.chain.from_iterable([range(34, 35), range(92, 93), range(97, 98), range(98, 99), range(102, 103), range(110, 111), range(114, 115), range(116, 117), range(118, 119), range(122, 123)])),
        16: list(itertools.chain.from_iterable([range(48, 51)])),
        17: list(itertools.chain.from_iterable([range(48, 53)])),
        18: list(itertools.chain.from_iterable([range(48, 58)])),
        19: list(itertools.chain.from_iterable([range(48, 58), range(65, 71), range(97, 103)])),
        20: list(itertools.chain.from_iterable([range(32, 127)])),
        21: list(itertools.chain.from_iterable([range(9, 10), range(10, 11), range(12, 13), range(13, 14), range(32, 33)])),
    }
